{{title: DBXTalkDrivers}}
{{author: DBXTalk Team}}
!Architecture and Design

!!Understanding OpenDBX architecture

It is very important you understand which components are present in this architecture and how they are related. To make this easy, suppose we have a client PC where your specific application resides and a server, where the database manager runs, suppose, it's oracle. This is the component diagram of that:

ComponentsUML

-MyApplication is just the application that uses OpenDBX and sees it like any other C library. Depending on the platform it could be a .dll, .so, etc.
-OpenDBX's architecture concist of an openDBX core which provides the user API, and then it has an OpenDBX backend for each RDBMS it supports. Both the core and all backends are part of OpenDBX library. OpenDBX core delegates to the appropriate backend (oracle in this case). There will be as many OpenDBX backends as database engines are supported. Each backend maps the OpenDBX API to the particular engine. This architecture allows the user to easily extend OpenDBX to another backend.
-Oracle client library is the library (written in c) your database vendor gives you so that you can talk to it. Most of the times, you have to install only a client package of the database (not the whole server).

!!DBXTalk architecture and design

This is the whole architecture of the open source solution we propose for relational database access.

DbxTalkLayers

Some notes:

-Common interface GLORP vs Drivers: GLORP has a common API between it and any database driver. In previous versions of Glorp for Pharo and Squeak, the database driver was hardcoded to PostgreSQL and it was the only database working. Part of our port Glorp port to Pharo includes also changes that provides this API between Glorp and database drivers.
-For each database driver, there must be a Glorp database driver for it. For example, GlorpOpenDBXDriver is the Glorp database driver for OpenDBXDriver. GlorpDriverPostgreSQL is the Glorp driver for the PostgreSQL native driver.
-OpenDBXDriver, MySQL native driver, etc, are all the database drivers. 

!!External call implementation

We are very proud of DBXTalk design. As an example, you could change the complete external call implementation very simple. Just add a subclass of OpenDBX class and us it.

The way we implement the external call is using FFI. It is known that when you execute a external function trough FFI, it blocks the virtual machine until the function returns. So, if the function takes a lot of time, the VM will be blocked for that time. Consider this situation for a RDBMS driver for a moment. It would be non usable at all. But, with DBXTalk we try to workarround this issue. This is because OpenDBX can work with *asynchronous queries>#*.

Of course FFI calls happen, but there are many "micro-blocks".
