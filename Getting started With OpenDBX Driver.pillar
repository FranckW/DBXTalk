{{title: DBXTalkDrivers}}
{{author: DBXTalk Team}}
!Getting started With OpenDBX Driver

!!Creating a database connection

The first step in order to execute a SQL statement in a database engine is to create a connection to that database. The DBXTalk OpenDBXDriver uses 3 objects to fulfill this objective: a connection object, which uses a platform/backend object and a connection settings object.

For example, to open a connection to a MySQL database called sodbxtest, located in localhost you can use the following code:

[[[|settings platform connection|
settings := DBXConnectionSettings
			host: 'localhost'
			port: '3306'
			database: 'sodbxtest'
			userName: 'sodbxtest'
			userPassword: 'sodbxtest'.
platform := DBXMySQLBackend new.
connection := DBXConnection platform: platform settings: settings.

connection connect.
connection open.]]]

As you can see, after creating the connection object, you have to send it first the ""#connect"" message to let OpenDBX create all the needded internal structure. After that, you can send it the ""#open"" message to associate the connection to the desired database, verify the credentials and enable us to start sending querys.

The main reason to separate these two operations is to configure some extra options before the connection is open. If you do not want to specify any of these options, you can send the ""#connectAndOpen"" message to the connection instead:

[[[
connection connectAndOpen.
]]]

*Advanced configuration>#*

!!Querying!

The execution of a SQL statement in the database of your desire is performed sending the ""#execute:"" message -or ""#executeMultiStatement:"" if enabled- to the connection object. So, once you have your connection established and open, you can try evaluating in a workspace code like:

[[[|connection|
"we create a table to store our trading card game cards in our MySQL database"
connection execute: 'CREATE TABLE CARD(ID INT AUTO_INCREMENT PRIMARY KEY, NAME VARCHAR(100))'.

"we insert some cards into our database"
connection execute: 'INSERT INTO CARDS (NAME) VALUES(''Giant Growth'')'.
connection execute: 'INSERT INTO CARDS (NAME) VALUES(''Llanowar Elves'')'.

"If we did enable multistatements before opening the connection we can do some inserts at the same time"
connection executeMultiStatement: 'INSERT INTO CARDS (NAME) VALUES(''Rancor'');
INSERT INTO CARDS (NAME) VALUES(''Counterspell'')'.

"we execute an invalid SQL statement to see how it raises a DBXError"
connection execute: 'some invalid sql statement'.]]]


!!!Fetching results

So far we have only executed statements without looking at their results. Each statement execution has a Result, which may be one of ""DBXResult"", ""DBXResultSet"" and ""DBXMultiStatementResultSetIterator"".

A ""DBXResult"" is obtained when executing a SQL statement which does not have a set of rows as a result -such as a CREATE TABLE, INSERT or UPDATE operation. You can ask it for its ""#rowsAffected"" to know how many rows were affected in the operation.

[[[result := connection execute: 'UPDATE CARDS SET NAME=''CounterSpell'' where NAME=''Counterspell'' '.
Transcript show: result rowsAffected.]]]

A SQL statement with rows as a result -such as a SELECT statement- brings a ""DBXResultSet"" as the result. A DBXResultSet is a consumable set of rows. This means that onces you've consumed all the rows in the DBXResultSet, they will not be available any more. You can work with a DBXResultSet in several ways:

[[["Delegate row iteration to the result set:"
cardsResultSet := connection execute: 'SELECT * FROM CARDS'.
cardsResultSet rowsDo: [ :row | Transcript show: (row valueAt: 1) ].

"Getting all rows from a result set:"
cardsResultSet := connection execute: 'SELECT * FROM CARDS'.
rows := cardsResultSet rows.
rows do: [ :row | Transcript show: (row valueAt: 1) ]

"Fetching one row at a time:"
cardsResultSet := connection execute: 'SELECT * FROM CARDS'.
[ row := cardsResultSet nextRow.
  row notNil ] 
    whileTrue: [ Transcript show: (row valueAt: 1); cr ]]]]

When accessing a ResultSet rows, we get some ""DBXRow"" instances to play with. A DBXRow is the model of a database row, and each of the values for it's columns can be accessed in two formats: the raw format, which is the string representation of the value, sent by the database, and a converted format, which is the Pharo object representation for that object. The DBXRow objects understand some of the following messages:

-""#valueAt:"" retrieves the converted value at the column in the given index.
-""#values"" retrieves a sequenceable collection with all the converted values of the row.
-""#rawValueAt:"" retrieves the raw value at the column in the given index.
-""#rawValues"" retrieves a sequenceable collection with all the raw values of the row.

Some examples of the behavior of a DBXRow are the following:

[[[myRow valueAt: 1. "-> 1          First column is INTEGER and contains a 1. It retrieves a Pharo SmallInteger"
myRow rawValueAt: 1. "-> '1'     First column is INTEGER and contains a 1. It retrieves an string"

myRow values. "-> #(1 'Llanowar Elves')   A collection with every row value converted to Pharo objects."
myRow rawValues. "-> #('1' 'Llanowar Elves') A collection with every row raw value."]]]

Finally, the other kind of result we can get from a SQL statement is a ""DBXMultiStatementResultSetIterator"". It stands as a DBXResultSet container, for multi-statement querys. You can browse the results using the following convenience methods.

[[["internal iteration of the results."
myMultistatementResult allResultsDo: [ :aResult | "doSometing here with the result" ].

"iterating the results one by one."
[result := myMultistatementResult next. result notNil] 
    whileTrue: [ :aResult | "doSometing here with the result" ].]]]
